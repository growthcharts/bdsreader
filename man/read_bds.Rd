% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/read_bds.R
\name{read_bds}
\alias{read_bds}
\title{Reads selected BDS data of a person}
\usage{
read_bds(
  txt = NULL,
  auto_format = TRUE,
  format = "1.0",
  schema = NULL,
  append_ddi = FALSE,
  verbose = FALSE,
  ...
)
}
\arguments{
\item{txt}{A JSON string, URL or file}

\item{auto_format}{Logical. Should the format be read from the data? Default is \code{TRUE}.}

\item{format}{String. JSON data schema version number. There are currently
three schemas supported: \code{"1.0"}, \code{"1.1"}, \code{"2.0"} and \code{"3.0"}. Formats \code{"1.0"} and
\code{"1.1"} are included for backward compatibility only. Use \code{format = "3.0"}
for new applications.}

\item{schema}{A file name (optionally including the path) with the JSON
validation schema.
The \code{schema} argument overrides \code{format}. The function extracts the
version number for the basename, and overwrites the
\code{format} argument by version number.}

\item{append_ddi}{Should the DDI responses be appended?}

\item{verbose}{Show verbose output for \code{\link[centile:y2z]{centile::y2z()}}}

\item{\dots}{Ignored}
}
\value{
A list with elements named \code{"psn"} and \code{"xyz"}.
}
\description{
This function takes data from a json source, validates the contents against a
JSON validation schema, perform checks, calculates the D-score, calculates
Z-scores and stores the data in an list with elements \code{psn} and \code{xyz}.
}
\details{
If \code{txt} is unspecified or \code{NULL}, then the function return will have zero rows.

The \code{format} and \code{schema} arguments specify the format of the JSON input
data argument \code{txt}. The default \code{format = "1.0"} expects that the JSON
input data conform to the schema specified in
\code{system.file("schemas/bds_v1.0.json", package = "bdsreader")}. This is only
supported for legacy. We recommend format \code{"3.0"}, which expects data
coded according to \code{system.file("schemas/bds_v3.0.json", package = "bdsreader")}.

The format can be specified in the JSON data file with an entry
named \code{Format}. For \code{auto_format == TRUE}, the data specification overrides
any \code{format} and \code{schema} arguments to the \code{read_bds()} function.
Schema \code{bds_v3.0.json} requires the \code{Format} field, so the correct format
is automatically set by the data.

Legacy note: If you erroneously read a JSON file of format \code{"1.0"} using
format \code{"2.0"} you may see an error:
\verb{Error in b[b$ElementNummer == f & !is.na(b$ElementNummer), "Waarde"] : incorrect number of dimensions}.
In that make sure that you are reading with the \code{format = "1.0"} argument.
Reversely, if you erroneously read a JSON file of format \code{"2.0"} using format
\code{"1.0"} you may see messages \verb{.ClientGegevens should be object} and
\verb{Missing 'ClientGegevens$Groepen'}. In that case, specify \code{format = "2.0"}.
}
\examples{
fn <- system.file("examples/maria.json", package = "bdsreader")
m <- read_bds(fn)

# Assume that jamesdemodata is installed locally.
# If not use remotes::install_github("growthcharts/jamesdemodata")

# Read file with input data according to format "3.0"
data2 <- system.file("extdata/bds_v3.0/smocc/Laura_S.json", package = "jamesdemodata")
q <- read_bds(data2)
q

# Equivalent, but specifying the built-in schema file bds_v3.0.json
schema2 <- system.file("schemas/bds_v3.0.json", package = "bdsreader")
r <- read_bds(data2, schema = schema2)
identical(q, r)

# Automatic detection of format 3.0
# s <- read_bds(data2)
# identical(q, s)

# Reading data with older format (bds_v1.0)
data1 <- system.file("extdata/bds_v1.0/smocc/Laura_S.json", package = "jamesdemodata")
t <- read_bds(data1)
t

# same, but using a built-in schema file
schema1 <- system.file("schemas/bds_v1.0.json", package = "bdsreader")
u <- read_bds(data1, schema = schema1)
identical(t, u)
}
\seealso{
\code{\link[jsonlite:fromJSON]{jsonlite::fromJSON()}}, \code{\link[centile:y2z]{centile::y2z()}}
}
\author{
Stef van Buuren 2021
}
